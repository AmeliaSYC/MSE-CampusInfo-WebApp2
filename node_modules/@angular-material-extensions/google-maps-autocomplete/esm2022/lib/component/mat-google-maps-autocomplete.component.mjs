import { Component, EventEmitter, forwardRef, Inject, Input, Output, ViewChild } from '@angular/core';
import { NG_VALUE_ACCESSOR, UntypedFormControl, Validators } from '@angular/forms';
import { MatValidateAddressDirective } from '../directives/address-validator/mat-address-validator.directive';
import { ApiKeyToken } from "../tokens";
import * as i0 from "@angular/core";
import * as i1 from "../services/script-loader.service";
import * as i2 from "@angular/common";
import * as i3 from "@angular/forms";
import * as i4 from "@angular/material/input";
import * as i5 from "@angular/material/form-field";
import * as i6 from "../directives/address-validator/mat-address-validator.directive";
export var Appearance;
(function (Appearance) {
    Appearance["STANDARD"] = "standard";
    Appearance["FILL"] = "fill";
    Appearance["OUTLINE"] = "outline";
    Appearance["LEGACY"] = "legacy";
})(Appearance || (Appearance = {}));
export class MatGoogleMapsAutocompleteComponent {
    ngZone;
    apiKey;
    loaderService;
    autocomplete;
    searchElementRef;
    addressLabelText = 'Address';
    placeholderText = 'Please enter the address';
    requiredErrorText = 'The address is required';
    invalidErrorText = 'The address is not valid';
    appearance = Appearance.STANDARD;
    value;
    address;
    country;
    placeIdOnly;
    strictBounds;
    types;
    // types: string[] = ['address'];
    type;
    autoCompleteOptions = {};
    onChange = new EventEmitter();
    onAutocompleteSelected = new EventEmitter();
    onGermanAddressMapped = new EventEmitter();
    onLocationSelected = new EventEmitter();
    onNewPlaceResult = new EventEmitter();
    addressValidator = new MatValidateAddressDirective();
    addressSearchControl = new UntypedFormControl({ value: null }, Validators.compose([
        Validators.required,
        this.addressValidator.validate()
    ]));
    propagateChange = (_) => {
    };
    constructor(ngZone, apiKey, loaderService) {
        this.ngZone = ngZone;
        this.apiKey = apiKey;
        this.loaderService = loaderService;
    }
    ngOnInit() {
        this.addressValidator.subscribe(this.onNewPlaceResult);
        const options = {
            // types: ['address'],
            // componentRestrictions: {country: this.country},
            placeIdOnly: this.placeIdOnly,
            strictBounds: this.strictBounds,
            // types: this.types,
            type: this.type
        };
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.componentRestrictions = { country: this.country } : null;
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.types = this.types : null;
        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);
        this.initGoogleMapsAutocomplete();
    }
    ngOnDestroy() {
        if (this.autocomplete) {
            google.maps.event.clearInstanceListeners(this.autocomplete);
        }
    }
    initGoogleMapsAutocomplete() {
        this.loaderService
            .loadScript(`https://maps.googleapis.com/maps/api/js?key=${this.apiKey}&libraries=places`)
            .then(() => {
            this.autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);
            this.autocomplete.addListener('place_changed', () => {
                this.ngZone.run(() => {
                    // get the place result
                    const place = this.autocomplete.getPlace();
                    const germanAddress = {
                        gmID: place.id,
                        icon: place.icon,
                        url: place.url,
                        placeID: place.place_id,
                        displayAddress: place.formatted_address,
                        name: place.name,
                        vicinity: place.vicinity,
                        locality: {},
                        state: {},
                        country: {},
                        geoLocation: { latitude: -1, longitude: -1 },
                    };
                    if (place.geometry && place.geometry.location) {
                        germanAddress.geoLocation.latitude = place.geometry.location.lat();
                        germanAddress.geoLocation.longitude = place.geometry.location.lng();
                    }
                    if (place.address_components) {
                        place.address_components.forEach(value => {
                            if (value.types.indexOf('street_number') > -1) {
                                germanAddress.streetNumber = value.short_name;
                            }
                            if (value.types.indexOf('route') > -1) {
                                germanAddress.streetName = value.long_name;
                            }
                            if (value.types.indexOf('postal_code') > -1) {
                                germanAddress.postalCode = Number(value.short_name);
                            }
                            if (value.types.indexOf('sublocality') > -1) {
                                germanAddress.sublocality = value.long_name;
                            }
                            if (value.types.indexOf('locality') > -1) {
                                germanAddress.locality.long = value.long_name;
                                germanAddress.locality.short = value.short_name;
                            }
                            if (value.types.indexOf('administrative_area_level_1') > -1) {
                                germanAddress.state.long = value.long_name;
                                germanAddress.state.short = value.short_name;
                            }
                            if (value.types.indexOf('country') > -1) {
                                germanAddress.country.long = value.long_name;
                                germanAddress.country.short = value.short_name;
                            }
                            if (value.types.indexOf('administrative_area_level_3') > -1) {
                                germanAddress.locality.short = value.short_name;
                            }
                        });
                    }
                    this.onGermanAddressMapped.emit(germanAddress);
                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {
                        // place result is not valid
                        return;
                    }
                    else {
                        // show dialog to select a address from the input
                        // emit failed event
                        this.value = place;
                        this.propagateChange(this.value);
                    }
                    this.address = place.formatted_address;
                    this.onAutocompleteSelected.emit(place);
                    this.onLocationSelected.emit({
                        latitude: place.geometry.location.lat(),
                        longitude: place.geometry.location.lng()
                    });
                });
            });
        })
            .catch((err) => console.log(err));
    }
    onQuery(event) {
        this.onChange.emit(this.address);
    }
    resetAddress() {
        this.address = null;
        this.addressSearchControl.updateValueAndValidity();
    }
    writeValue(obj) {
        if (obj) {
            this.value = obj;
        }
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        throw new Error('Method not implemented.');
    }
    setDisabledState(isDisabled) {
        throw new Error('Method not implemented.');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, deps: [{ token: i0.NgZone }, { token: ApiKeyToken }, { token: i1.ScriptLoaderService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.2", type: MatGoogleMapsAutocompleteComponent, selector: "mat-google-maps-autocomplete", inputs: { addressLabelText: "addressLabelText", placeholderText: "placeholderText", requiredErrorText: "requiredErrorText", invalidErrorText: "invalidErrorText", appearance: "appearance", value: "value", address: "address", country: "country", placeIdOnly: "placeIdOnly", strictBounds: "strictBounds", types: "types", type: "type", autoCompleteOptions: "autoCompleteOptions" }, outputs: { onChange: "onChange", onAutocompleteSelected: "onAutocompleteSelected", onGermanAddressMapped: "onGermanAddressMapped", onLocationSelected: "onLocationSelected" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),
                multi: true
            }
        ], viewQueries: [{ propertyName: "searchElementRef", first: true, predicate: ["search"], descendants: true }], exportAs: ["matGoogleMapsAutocomplete"], ngImport: i0, template: "<mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n  <mat-label>{{addressLabelText}}</mat-label>\n  <input matInput\n         [(ngModel)]=\"address\"\n         (change)=\"onQuery($event)\"\n         placeholder=\"{{placeholderText}}\"\n         class=\"form-control\"\n         #search\n         MatValidateAddress\n         required>\n  <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n    {{requiredErrorText}}\n  </mat-error>\n  <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n    {{invalidErrorText}}\n  </mat-error>\n</mat-form-field>\n", styles: [".full-width{width:100%}\n"], dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "directive", type: i3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i4.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i5.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i5.MatLabel, selector: "mat-label" }, { kind: "directive", type: i5.MatError, selector: "mat-error, [matError]", inputs: ["id"] }, { kind: "directive", type: i6.MatValidateAddressDirective, selector: "[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, decorators: [{
            type: Component,
            args: [{ selector: 'mat-google-maps-autocomplete', exportAs: 'matGoogleMapsAutocomplete', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),
                            multi: true
                        }
                    ], template: "<mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n  <mat-label>{{addressLabelText}}</mat-label>\n  <input matInput\n         [(ngModel)]=\"address\"\n         (change)=\"onQuery($event)\"\n         placeholder=\"{{placeholderText}}\"\n         class=\"form-control\"\n         #search\n         MatValidateAddress\n         required>\n  <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n    {{requiredErrorText}}\n  </mat-error>\n  <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n    {{invalidErrorText}}\n  </mat-error>\n</mat-form-field>\n", styles: [".full-width{width:100%}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [ApiKeyToken]
                }] }, { type: i1.ScriptLoaderService }]; }, propDecorators: { searchElementRef: [{
                type: ViewChild,
                args: ['search']
            }], addressLabelText: [{
                type: Input
            }], placeholderText: [{
                type: Input
            }], requiredErrorText: [{
                type: Input
            }], invalidErrorText: [{
                type: Input
            }], appearance: [{
                type: Input
            }], value: [{
                type: Input
            }], address: [{
                type: Input
            }], country: [{
                type: Input
            }], placeIdOnly: [{
                type: Input
            }], strictBounds: [{
                type: Input
            }], types: [{
                type: Input
            }], type: [{
                type: Input
            }], autoCompleteOptions: [{
                type: Input
            }], onChange: [{
                type: Output
            }], onAutocompleteSelected: [{
                type: Output
            }], onGermanAddressMapped: [{
                type: Output
            }], onLocationSelected: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LWdvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLW1hdGVyaWFsLWV4dGVuc2lvbnMvZ29vZ2xlLW1hcHMtYXV0b2NvbXBsZXRlL3NyYy9saWIvY29tcG9uZW50L21hdC1nb29nbGUtbWFwcy1hdXRvY29tcGxldGUuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1tYXRlcmlhbC1leHRlbnNpb25zL2dvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS9zcmMvbGliL2NvbXBvbmVudC9tYXQtZ29vZ2xlLW1hcHMtYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBRVQsWUFBWSxFQUNaLFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUlMLE1BQU0sRUFDTixTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF1QixpQkFBaUIsRUFBRSxrQkFBa0IsRUFBRSxVQUFVLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2RyxPQUFPLEVBQUMsMkJBQTJCLEVBQUMsTUFBTSxpRUFBaUUsQ0FBQztBQUk1RyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sV0FBVyxDQUFDOzs7Ozs7OztBQUl0QyxNQUFNLENBQU4sSUFBWSxVQUtYO0FBTEQsV0FBWSxVQUFVO0lBQ3BCLG1DQUFxQixDQUFBO0lBQ3JCLDJCQUFhLENBQUE7SUFDYixpQ0FBbUIsQ0FBQTtJQUNuQiwrQkFBaUIsQ0FBQTtBQUNuQixDQUFDLEVBTFcsVUFBVSxLQUFWLFVBQVUsUUFLckI7QUFlRCxNQUFNLE9BQU8sa0NBQWtDO0lBdUV6QjtJQUVEO0lBQ0M7SUF4RXBCLFlBQVksQ0FBOEM7SUFHbkQsZ0JBQWdCLENBQWE7SUFHcEMsZ0JBQWdCLEdB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dWxCQWlCQTs7MkZEeUJhLGtDQUFrQztrQkFiOUMsU0FBUzsrQkFDRSw4QkFBOEIsWUFDOUIsMkJBQTJCLGFBRzFCO3dCQUNUOzRCQUNFLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLG1DQUFtQyxDQUFDOzRCQUNqRSxLQUFLLEVBQUUsSUFBSTt5QkFDWjtxQkFDRjs7MEJBMEVZLE1BQU07MkJBQUMsV0FBVzs4RUFuRXhCLGdCQUFnQjtzQkFEdEIsU0FBUzt1QkFBQyxRQUFRO2dCQUluQixnQkFBZ0I7c0JBRGYsS0FBSztnQkFJTixlQUFlO3NCQURkLEtBQUs7Z0JBSU4saUJBQWlCO3NCQURoQixLQUFLO2dCQUlOLGdCQUFnQjtzQkFEZixLQUFLO2dCQUlOLFVBQVU7c0JBRFQsS0FBSztnQkFJTixLQUFLO3NCQURKLEtBQUs7Z0JBSU4sT0FBTztzQkFETixLQUFLO2dCQUlOLE9BQU87c0JBRE4sS0FBSztnQkFJTixXQUFXO3NCQURWLEtBQUs7Z0JBSU4sWUFBWTtzQkFEWCxLQUFLO2dCQUlOLEtBQUs7c0JBREosS0FBSztnQkFLTixJQUFJO3NCQURILEtBQUs7Z0JBSU4sbUJBQW1CO3NCQURsQixLQUFLO2dCQUlOLFFBQVE7c0JBRFAsTUFBTTtnQkFJUCxzQkFBc0I7c0JBRHJCLE1BQU07Z0JBSVAscUJBQXFCO3NCQURwQixNQUFNO2dCQUlQLGtCQUFrQjtzQkFEakIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBmb3J3YXJkUmVmLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SLCBVbnR5cGVkRm9ybUNvbnRyb2wsIFZhbGlkYXRvcnN9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7TWF0VmFsaWRhdGVBZGRyZXNzRGlyZWN0aXZlfSBmcm9tICcuLi9kaXJlY3RpdmVzL2FkZHJlc3MtdmFsaWRhdG9yL21hdC1hZGRyZXNzLXZhbGlkYXRvci5kaXJlY3RpdmUnO1xuaW1wb3J0IHtMb2NhdGlvbn0gZnJvbSAnLi4vaW50ZXJmYWNlcy9sb2NhdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHtHZXJtYW5BZGRyZXNzfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7U2NyaXB0TG9hZGVyU2VydmljZX0gZnJvbSBcIi4uL3NlcnZpY2VzL3NjcmlwdC1sb2FkZXIuc2VydmljZVwiO1xuaW1wb3J0IHtBcGlLZXlUb2tlbn0gZnJvbSBcIi4uL3Rva2Vuc1wiO1xuaW1wb3J0IFBsYWNlUmVzdWx0ID0gZ29vZ2xlLm1hcHMucGxhY2VzLlBsYWNlUmVzdWx0O1xuaW1wb3J0IEF1dG9jb21wbGV0ZU9wdGlvbnMgPSBnb29nbGUubWFwcy5wbGFjZXMuQXV0b2NvbXBsZXRlT3B0aW9ucztcblxuZXhwb3J0IGVudW0gQXBwZWFyYW5jZSB7XG4gIFNUQU5EQVJEID0gJ3N0YW5kYXJkJyxcbiAgRklMTCA9ICdmaWxsJyxcbiAgT1VUTElORSA9ICdvdXRsaW5lJyxcbiAgTEVHQUNZID0gJ2xlZ2FjeScsXG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21hdC1nb29nbGUtbWFwcy1hdXRvY29tcGxldGUnLFxuICBleHBvcnRBczogJ21hdEdvb2dsZU1hcHNBdXRvY29tcGxldGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vbWF0LWdvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL21hdC1nb29nbGUtbWFwcy1hdXRvY29tcGxldGUuY29tcG9uZW50LnNjc3MnXSxcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNYXRHb29nbGVNYXBzQXV0b2NvbXBsZXRlQ29tcG9uZW50KSxcbiAgICAgIG11bHRpOiB0cnVlXG4gICAgfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIE1hdEdvb2dsZU1hcHNBdXRvY29tcGxldGVDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gIGF1dG9jb21wbGV0ZTogZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZSB8IHVuZGVmaW5lZDtcblxuICBAVmlld0NoaWxkKCdzZWFyY2gnKVxuICBwdWJsaWMgc2VhcmNoRWxlbWVudFJlZjogRWxlbWVudFJlZjtcblxuICBASW5wdXQoKVxuICBhZGRyZXNzTGFiZWxUZXh0ID0gJ0FkZHJlc3MnO1xuXG4gIEBJbnB1dCgpXG4gIHBsYWNlaG9sZGVyVGV4dCA9ICdQbGVhc2UgZW50ZXIgdGhlIGFkZHJlc3MnO1xuXG4gIEBJbnB1dCgpXG4gIHJlcXVpcmVkRXJyb3JUZXh0ID0gJ1RoZSBhZGRyZXNzIGlzIHJlcXVpcmVkJztcblxuICBASW5wdXQoKVxuICBpbnZhbGlkRXJyb3JUZXh0ID0gJ1RoZSBhZGRyZXNzIGlzIG5vdCB2YWxpZCc7XG5cbiAgQElucHV0KClcbiAgYXBwZWFyYW5jZTogc3RyaW5nIHwgQXBwZWFyYW5jZSA9IEFwcGVhcmFuY2UuU1RBTkRBUkQ7XG5cbiAgQElucHV0KClcbiAgdmFsdWU6IFBsYWNlUmVzdWx0O1xuXG4gIEBJbnB1dCgpXG4gIGFkZHJlc3M6IFBsYWNlUmVzdWx0IHwgc3RyaW5nO1xuXG4gIEBJbnB1dCgpXG4gIGNvdW50cnk6IHN0cmluZyB8IHN0cmluZ1tdO1xuXG4gIEBJbnB1dCgpXG4gIHBsYWNlSWRPbmx5PzogYm9vbGVhbjtcblxuICBASW5wdXQoKVxuICBzdHJpY3RCb3VuZHM/OiBib29sZWFuO1xuXG4gIEBJbnB1dCgpXG4gIHR5cGVzPzogc3RyaW5nW107XG4gIC8vIHR5cGVzOiBzdHJpbmdbXSA9IFsnYWRkcmVzcyddO1xuXG4gIEBJbnB1dCgpXG4gIHR5cGU/OiBzdHJpbmc7XG5cbiAgQElucHV0KClcbiAgYXV0b0NvbXBsZXRlT3B0aW9uczogQXV0b2NvbXBsZXRlT3B0aW9ucyA9IHt9O1xuXG4gIEBPdXRwdXQoKVxuICBvbkNoYW5nZTogRXZlbnRFbWl0dGVyPFBsYWNlUmVzdWx0IHwgc3RyaW5nIHwgbnVsbD4gPSBuZXcgRXZlbnRFbWl0dGVyPFBsYWNlUmVzdWx0IHwgc3RyaW5nIHwgbnVsbD4oKTtcblxuICBAT3V0cHV0KClcbiAgb25BdXRvY29tcGxldGVTZWxlY3RlZDogRXZlbnRFbWl0dGVyPFBsYWNlUmVzdWx0PiA9IG5ldyBFdmVudEVtaXR0ZXI8UGxhY2VSZXN1bHQ+KCk7XG5cbiAgQE91dHB1dCgpXG4gIG9uR2VybWFuQWRkcmVzc01hcHBlZDogRXZlbnRFbWl0dGVyPEdlcm1hbkFkZHJlc3M+ID0gbmV3IEV2ZW50RW1pdHRlcjxHZXJtYW5BZGRyZXNzPigpO1xuXG4gIEBPdXRwdXQoKVxuICBvbkxvY2F0aW9uU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxMb2NhdGlvbj4gPSBuZXcgRXZlbnRFbWl0dGVyPExvY2F0aW9uPigpO1xuXG5cbiAgcHJpdmF0ZSBvbk5ld1BsYWNlUmVzdWx0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgcHJpdmF0ZSBhZGRyZXNzVmFsaWRhdG9yOiBNYXRWYWxpZGF0ZUFkZHJlc3NEaXJlY3RpdmUgPSBuZXcgTWF0VmFsaWRhdGVBZGRyZXNzRGlyZWN0aXZlKCk7XG5cbiAgcHVibGljIGFkZHJlc3NTZWFyY2hDb250cm9sOiBVbnR5cGVkRm9ybUNvbnRyb2wgPSBuZXcgVW50eXBlZEZvcm1Db250cm9sKHt2YWx1ZTogbnVsbH0sIFZhbGlkYXRvcnMuY29tcG9zZShbXG4gICAgVmFsaWRhdG9ycy5yZXF1aXJlZCxcbiAgICB0aGlzLmFkZHJlc3NWYWxpZGF0b3IudmFsaWRhdGUoKV0pXG4gICk7XG5cbiAgcHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4ge1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmdab25lOiBOZ1pvbmUsXG4gICAgICAgICAgICAgIEBJbmplY3QoQXBpS2V5VG9rZW4pXG4gICAgICAgICAgICAgIHB1YmxpYyBhcGlLZXk6IHN0cmluZyxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBsb2FkZXJTZXJ2aWNlOiBTY3JpcHRMb2FkZXJTZXJ2aWNlLCkge1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5hZGRyZXNzVmFsaWRhdG9yLnN1YnNjcmliZSh0aGlzLm9uTmV3UGxhY2VSZXN1bHQpO1xuXG4gICAgY29uc3Qgb3B0aW9uczogQXV0b2NvbXBsZXRlT3B0aW9ucyA9IHtcbiAgICAgIC8vIHR5cGVzOiBbJ2FkZHJlc3MnXSxcbiAgICAgIC8vIGNvbXBvbmVudFJlc3RyaWN0aW9uczoge2NvdW50cnk6IHRoaXMuY291bnRyeX0sXG4gICAgICBwbGFjZUlkT25seTogdGhpcy5wbGFjZUlkT25seSxcbiAgICAgIHN0cmljdEJvdW5kczogdGhpcy5zdHJpY3RCb3VuZHMsXG4gICAgICAvLyB0eXBlczogdGhpcy50eXBlcyxcbiAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgIH07XG5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICB0aGlzLmNvdW50cnkgPyBvcHRpb25zLmNvbXBvbmVudFJlc3RyaWN0aW9ucyA9IHtjb3VudHJ5OiB0aGlzLmNvdW50cnl9IDogbnVsbDtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICB0aGlzLmNvdW50cnkgPyBvcHRpb25zLnR5cGVzID0gdGhpcy50eXBlcyA6IG51bGw7XG5cbiAgICB0aGlzLmF1dG9Db21wbGV0ZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHRoaXMuYXV0b0NvbXBsZXRlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5pbml0R29vZ2xlTWFwc0F1dG9jb21wbGV0ZSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYXV0b2NvbXBsZXRlKSB7XG4gICAgICBnb29nbGUubWFwcy5ldmVudC5jbGVhckluc3RhbmNlTGlzdGVuZXJzKHRoaXMuYXV0b2NvbXBsZXRlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaW5pdEdvb2dsZU1hcHNBdXRvY29tcGxldGUoKSB7XG4gICAgdGhpcy5sb2FkZXJTZXJ2aWNlXG4gICAgICAubG9hZFNjcmlwdChgaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzP2tleT0ke3RoaXMuYXBpS2V5fSZsaWJyYXJpZXM9cGxhY2VzYClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUgPSBuZXcgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZSh0aGlzLnNlYXJjaEVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5hdXRvQ29tcGxldGVPcHRpb25zKTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuYWRkTGlzdGVuZXIoJ3BsYWNlX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcGxhY2UgcmVzdWx0XG4gICAgICAgICAgICBjb25zdCBwbGFjZTogUGxhY2VSZXN1bHQgPSB0aGlzLmF1dG9jb21wbGV0ZS5nZXRQbGFjZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBnZXJtYW5BZGRyZXNzOiBHZXJtYW5BZGRyZXNzID0ge1xuICAgICAgICAgICAgICBnbUlEOiBwbGFjZS5pZCxcbiAgICAgICAgICAgICAgaWNvbjogcGxhY2UuaWNvbixcbiAgICAgICAgICAgICAgdXJsOiBwbGFjZS51cmwsXG4gICAgICAgICAgICAgIHBsYWNlSUQ6IHBsYWNlLnBsYWNlX2lkLFxuICAgICAgICAgICAgICBkaXNwbGF5QWRkcmVzczogcGxhY2UuZm9ybWF0dGVkX2FkZHJlc3MsXG4gICAgICAgICAgICAgIG5hbWU6IHBsYWNlLm5hbWUsXG4gICAgICAgICAgICAgIHZpY2luaXR5OiBwbGFjZS52aWNpbml0eSxcbiAgICAgICAgICAgICAgbG9jYWxpdHk6IHt9LFxuICAgICAgICAgICAgICBzdGF0ZToge30sXG4gICAgICAgICAgICAgIGNvdW50cnk6IHt9LFxuICAgICAgICAgICAgICBnZW9Mb2NhdGlvbjoge2xhdGl0dWRlOiAtMSwgbG9uZ2l0dWRlOiAtMX0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAocGxhY2UuZ2VvbWV0cnkgJiYgcGxhY2UuZ2VvbWV0cnkubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5nZW9Mb2NhdGlvbi5sYXRpdHVkZSA9IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxhdCgpO1xuICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLmdlb0xvY2F0aW9uLmxvbmdpdHVkZSA9IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGxhY2UuYWRkcmVzc19jb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgIHBsYWNlLmFkZHJlc3NfY29tcG9uZW50cy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZignc3RyZWV0X251bWJlcicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3Muc3RyZWV0TnVtYmVyID0gdmFsdWUuc2hvcnRfbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGVzLmluZGV4T2YoJ3JvdXRlJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5zdHJlZXROYW1lID0gdmFsdWUubG9uZ19uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZigncG9zdGFsX2NvZGUnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLnBvc3RhbENvZGUgPSBOdW1iZXIodmFsdWUuc2hvcnRfbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdzdWJsb2NhbGl0eScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3Muc3VibG9jYWxpdHkgPSB2YWx1ZS5sb25nX25hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdsb2NhbGl0eScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3MubG9jYWxpdHkubG9uZyA9IHZhbHVlLmxvbmdfbmFtZTtcbiAgICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3MubG9jYWxpdHkuc2hvcnQgPSB2YWx1ZS5zaG9ydF9uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZignYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8xJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5zdGF0ZS5sb25nID0gdmFsdWUubG9uZ19uYW1lO1xuICAgICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5zdGF0ZS5zaG9ydCA9IHZhbHVlLnNob3J0X25hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdjb3VudHJ5JykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5jb3VudHJ5LmxvbmcgPSB2YWx1ZS5sb25nX25hbWU7XG4gICAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLmNvdW50cnkuc2hvcnQgPSB2YWx1ZS5zaG9ydF9uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZignYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8zJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5sb2NhbGl0eS5zaG9ydCA9IHZhbHVlLnNob3J0X25hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vbkdlcm1hbkFkZHJlc3NNYXBwZWQuZW1pdChnZXJtYW5BZGRyZXNzKTtcblxuICAgICAgICAgICAgaWYgKCFwbGFjZS5wbGFjZV9pZCB8fCBwbGFjZS5nZW9tZXRyeSA9PT0gdW5kZWZpbmVkIHx8IHBsYWNlLmdlb21ldHJ5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIHBsYWNlIHJlc3VsdCBpcyBub3QgdmFsaWRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc2hvdyBkaWFsb2cgdG8gc2VsZWN0IGEgYWRkcmVzcyBmcm9tIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAvLyBlbWl0IGZhaWxlZCBldmVudFxuICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcGxhY2U7XG4gICAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlKHRoaXMudmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MgPSBwbGFjZS5mb3JtYXR0ZWRfYWRkcmVzcztcbiAgICAgICAgICAgIHRoaXMub25BdXRvY29tcGxldGVTZWxlY3RlZC5lbWl0KHBsYWNlKTtcbiAgICAgICAgICAgIHRoaXMub25Mb2NhdGlvblNlbGVjdGVkLmVtaXQoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogcGxhY2UuZ2VvbWV0cnkubG9jYXRpb24ubGF0KCksXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBwbGFjZS5nZW9tZXRyeS5sb2NhdGlvbi5sbmcoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IGNvbnNvbGUubG9nKGVycikpO1xuICB9XG5cbiAgcHVibGljIG9uUXVlcnkoZXZlbnQ6IGFueSkge1xuICAgIHRoaXMub25DaGFuZ2UuZW1pdCh0aGlzLmFkZHJlc3MpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldEFkZHJlc3MoKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gbnVsbDtcbiAgICB0aGlzLmFkZHJlc3NTZWFyY2hDb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgfVxuXG4gIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAob2JqKSB7XG4gICAgICB0aGlzLnZhbHVlID0gb2JqO1xuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZT8oaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG59XG4iLCI8bWF0LWZvcm0tZmllbGQgY2xhc3M9XCJmdWxsLXdpZHRoXCIgW2FwcGVhcmFuY2VdPVwiYXBwZWFyYW5jZVwiPlxuICA8bWF0LWxhYmVsPnt7YWRkcmVzc0xhYmVsVGV4dH19PC9tYXQtbGFiZWw+XG4gIDxpbnB1dCBtYXRJbnB1dFxuICAgICAgICAgWyhuZ01vZGVsKV09XCJhZGRyZXNzXCJcbiAgICAgICAgIChjaGFuZ2UpPVwib25RdWVyeSgkZXZlbnQpXCJcbiAgICAgICAgIHBsYWNlaG9sZGVyPVwie3twbGFjZWhvbGRlclRleHR9fVwiXG4gICAgICAgICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAjc2VhcmNoXG4gICAgICAgICBNYXRWYWxpZGF0ZUFkZHJlc3NcbiAgICAgICAgIHJlcXVpcmVkPlxuICA8bWF0LWVycm9yICpuZ0lmPVwiYWRkcmVzc1NlYXJjaENvbnRyb2wuaGFzRXJyb3IoJ3JlcXVpcmVkJylcIj5cbiAgICB7e3JlcXVpcmVkRXJyb3JUZXh0fX1cbiAgPC9tYXQtZXJyb3I+XG4gIDxtYXQtZXJyb3IgKm5nSWY9XCJhZGRyZXNzU2VhcmNoQ29udHJvbC5oYXNFcnJvcigndmFsaWRhdGVBZGRyZXNzJylcIj5cbiAgICB7e2ludmFsaWRFcnJvclRleHR9fVxuICA8L21hdC1lcnJvcj5cbjwvbWF0LWZvcm0tZmllbGQ+XG4iXX0=